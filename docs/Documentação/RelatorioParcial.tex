% Relatório de Projeto de Iniciação Científica
% Iniciado no dia 1o. de abril de 2001

\documentclass[a4paper,12pt]{report}
\usepackage[brazil]{babel}
\author{Marco Aurélio Graciotto Silva}
\title{Uma Ferramenta para Apoiar a Definição de Requisitos no Desenvolvimento de Software Distribuído}

\begin{document}

\maketitle
\footnote{Última alteração feita em \today}

\tableofcontents

\section{Sobre}
Este documento, além de um relatório de meu projeto de Iniciação Científica, é minha primeira incursão nesta fantástica tecnologia (\TeX) e ferramenta (\LaTeXe). O bom é dizer que não foi difícil. Todos deveriam usá-lo.
\section

\section{Devaneio}
Engenharia de Software é a ciência que estuda maneiras de transformar desejos e necessidades humanas em realidade computacional, buscando sempre tecnologias para fazê-lo em prazos menores, com mais qualidade e com baixo custo (apesar desta definição parecer, talvez, um tanto quanto fantasiosa, é a mais absoluta verdade).

Podemos visualizar várias épocas do desenvolvimento desta ciência. Até fins do segundo milênio, deparavámos com o alto custo do hardware necessária tanto para implementar as soluções quanto para executá-las. Com a ajuda da lei de Moore (e muito investimento das indústrias), temos hoje uma situação antes imaginada de milhões de computadores, com poder de processamento fantástico, interligados através de uma rede padronizada e aceitavelmente rápida. Deslumbrando este cenário, imaginaria-se o custo de produção de um software cair rapidamente. No entanto, não é isso o que se observa: a indústria do software não está preparada para isso. Faltam padrões suficientemente testados e os poucos que existem não são totalmente suportados. Salvam-se exceções como XML e Corba, além das várias linguagens de programação desenvolvidas nas últimas décadas (Java, C, C++, PHP, Perl, LISP, Prolog, etc).

Mesmo assim, existe tecnologia para desenvolver os softwares que os seres humanos anseiam. No entanto, faltam as ferramentas que empreguem tais tecnologias. Os melhores ambientes de desenvolvimento de software ou cuidam apenas da codificação ou então da parte de projeto. Não temos nada que unifique (ou melhor, integre) tudo para que o processo se agilize, sem perda de qualidade.

Uma solução para isso são objetos distribuídos. Através de um middleware que permite que diferentes aplicações de diferentes plataformas conversem entre si, torna-se possível montar o que talvez seja a primeira geração de sistemas que suportem o desenvolvimento de software, nesta nova realidade, abordando todas as etapas necessárias. Exemplos próximos disso são o Rational ClearCase e o Unisys ?. No entanto, seus custos são muito altos, evitando que se difundam (é o custo do pioneirismo).

A segunda geração teria, como grande diferencial, o custo: zero. Isso vem de uma situação, que encontramos desde os primórdios da computação, que é o desenvolvimento de software livre. E livre quer dizer justamente isso: documentação e código disponível e irrestrito, desenvolvedores e meros mortais estão no mesmo nível. Pode-se até dizer que é praticamente um comunismo.

Obviamente, a palavra "custo" foi colocada ali apenas para chamar a atenção. Na verdade, a coisa é muito mais ampla que somente o preço. A liberdade deste modelo de desenvolvimento permite a criação de sistemas distribuídos simplesmente soberbos. Imagine que tudo que foi produzido até agora para desenvolvimento de código (compiladores e ambientes RAD) será integrados a ferramentas de projeto. O impacto da alteração de um requisito pode ser simulada em questões de segundos, evitando custos desnecessários. E o contrário também seria válido: avaliar que partes de um programa a alteração de uma linha de código pode afetar. Coisas estas até então inimagináveis poderão tornasse realidade.

Infelizmente, algo deste tamanho não pode ser feito da noite para o dia. Tal qual os antigos compiladores, feitos em Assembly para somente depois serem feitos em C, o desenvolvimento deste sistema será árduo e lento. Mas deve ser feito. E deve ser bem feito. Por isso, aplicar-se-á as metodologias e tecnologias de desenvolvimento de software mais adequadas até então estudadas (projeto orientado a objetos, objetos distribuídos, sistemas distribuídos), infelizmente de uma maneira rústica, já que não dispõe de ferramentas adequadas. 

O primeiro passo para tal sistema é a criação de uma ferramenta para analisar seus requisitos. Fundamenta-se isso no fato que, quanto mais cedo descobrirmos problemas, melhor. E, na verdade, temos de saber muito bem o que temos de fazer, caso contrário isso só termina no próximo século, versão 230.22.0, após infinitas noites de insônia e milhares de litros de café. :)

\section{Introdução}

A Engenharia de Requisitos é uma ciência que estuda e desenvolve técnicas e métodos para capturar, analisar e formalizar os requisitos de um software de maneira eficiente, ou seja, atuando na etapa inicial do desenvolvimeno de um software. Seu surgimento deveu-se a constatação que muitos dos projetos falham justamente porque os requisitos foram mal capturados e interpretados, tanto pelos desenvolvedores quanto pelos usuários.

Muito esforço tem sido feito ultimamente para aumentar a eficácia da análise dos requisitos, com desenvolvimentos de várias abordagens e padrões de documentação. No entanto, é evidente a falta de ferramentas que suportem tais tecnologias. O objetivo do projeto é justamente desenvolver uma ferramenta que apoie esta etapa vital do desenvolvimento do software, utilizando-se de blábláblá.

\section{Objetivos}

\section{}





\end{document}